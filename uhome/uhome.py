import time
import json

class Device:

    _mqttc = None # MQTT Client, provided by the user.
    _entities = [] # List of entities that belong to this device.

    def __init__(self, device_name, discovery_prefix='homeassistant', **kwargs):
        """
        Initializes the device with the given name and optional keyword arguments passed
        directly to the Home Assistant config.
        
        @param device_name: The name of the device.
        @type device_name: str
        
        @param discovery_prefix: The prefix used for discovery topics. Defaults to 'homeassistant'.
        @type discovery_prefix: str, optional
        
        @param kwargs: Additional keyword arguments to be added to the configuration of the device.
        
        @note: The device ID is generated by replacing spaces in the device name with underscores
        and converting to lowercase.
        """
        self.name = device_name
        self.id = self.name.replace(' ', '_').lower() # TODO: ö, ä, ü, ... not handled!
        self.discovery_prefix = discovery_prefix
        self.will_topic = f'{self.discovery_prefix}/availability/{self.id}'
        self.ha_status_topic = f'{self.discovery_prefix}/status'
        self.ha_status = None  # Last received HA status ( b'online' / b'offline')
        self.device = kwargs
        self.device['name'] = self.name
        self.device['ids'] = self.id

    def connect(self, mqttc):
        """
        @brief Connects to the MQTT broker and sets up the necessary configurations.
        
        @param mqttc: The MQTT client instance to be used for the connection.
        
        This method performs the following actions:
        - Stores the provided MQTT client instance.
        - Sets the ping interval based on the client's keepalive value.
        - Sets the last will message to indicate the device is offline if it disconnects unexpectedly.
        - Sets the callback function for incoming MQTT messages.
        - Connects to the MQTT broker.
        - Publishes a message to indicate the device is online.
        
        @note The MQTT client instance must be properly configured before calling this method.
        """
        self._mqttc = mqttc
        self.ping_interval = int(self._mqttc.keepalive * 0.8)
        self._last_ping = time.time()
        self._mqttc.set_last_will(self.will_topic, 'offline', retain=True)
        self._mqttc.set_callback(self.mqtt_callback)
        self._mqttc.connect()
        self._mqttc.publish(self.will_topic, 'online', retain=True)
        self._mqttc.subscribe(self.ha_status_topic)
        

    def mqtt_callback(self, topic, msg):
        """
        @brief Callback function for handling incoming MQTT messages.
        
        This function is called whenever a message is received on a subscribed MQTT topic.
        It decodes the topic and message, and then iterates through the list of entities
        to find the matching topic. If a match is found, it triggers the corresponding
        action for that entity.
        
        @param topic: The topic of the received MQTT message (bytes).
        
        @param msg: The payload of the received MQTT message (bytes).
        """
        decoded_topic = topic.decode()
        for entity in self._entities:
            if decoded_topic == entity.topic:
                entity._action(msg.decode())
        if decoded_topic == self.ha_status_topic:
            self.ha_status = msg
            if msg == b'online':
                print ("INFO: HA state online")
                self.discover_all()
            elif msg == b'offline':
                print ("INFO: HA state offline")
            else:
                print (f"WARN: Unknown HA state received: {msg}")


    def loop(self):
        """
        @brief Main loop function to handle MQTT broker ping and message checking.
        
        This function performs two main tasks:
        1. Sends a ping to the MQTT broker if the ping interval has elapsed.
        2. Checks for new MQTT messages.
        
        @note This function handles the main loop of the device and should be called regularly.
        """
        ### Broker ping (required for Mosquitto >= 2.0!)
        now = time.time()
        if (now - self._last_ping) > self.ping_interval:
            self._mqttc.ping()
            self._last_ping = now
        
        self._mqttc.check_msg() # Check for new MQTT messages


    def sleep_ms(self,ms):
        """
        @brief Wrapper for time.sleep_ms()

        @note Allows reimplemantation in child class if needed
        """
        time.sleep_ms(ms)


    def discover_all(self):
        """
        @brief (Re-)sends the discovery message for all entities to Home Assistant.
        
        This method iterates over all entities assigned to the device and calls
        their `discover` method to (re-)send the discovery message to Home Assistant.
        """
        for entity in self._entities:
            entity.discover()
        self.sleep_ms(3000)     # NOTE: This is ugly 
                                # Seems sending payload just after sending discovery paylod sometimes does not work
                                # Perhpahs we should send at once, ofert 1 sec, 3 secs 10 secs ?
        for entity in self._entities:
            entity.publish_last_payload()

        for entity in self._entities:
            entity.publish_last_payload()

class Entity:  

    def __init__(self, device, entity_name, **kwargs):
        """
        Create a new entity for the device.
        
        @param device: The device to which this entity belongs.
        @type device: Device
        
        @param entity_name: The name of the entity.
        @type entity_name: str
        
        @param kwargs: Additional configuration parameters for the entity,
        passed directly to the Home Assistant configuration.
        @type kwargs: dict
        """
        self.device = device
        self.device._entities.append(self)
        self.name = entity_name
        self.entity = entity_name.replace(' ', '_').lower()
        self.unique_id = f"{self.device.id}_{self.entity}"
        self.topic_prefix = f'{self.device.discovery_prefix}/{self.entity_type}/{self.device.id}'
        self.discovery_topic = f'{self.topic_prefix}/{self.entity}/config'
        self.topic = f'{self.topic_prefix}/state/{self.entity}'
        self.conf = self.make_conf(**kwargs)


    def __str__(self):
        return f"{self.__class__.__name__}-{self.entity}"

    def make_conf(self, **kwargs):
        """
        Internal method to generate a configuration dictionary for the device.
        
        @param kwargs: Additional configuration parameters to be added to the dictionary.
        
        @return: A dictionary containing the configuration for the device.
            - "name": The name of the device.
            - "dev": The device identifier.
            - "uniq_id": The unique identifier for the device.
            - "avty_t": The availability topic for the device.
            - "stat_t": The state topic for sensors and binary sensors.
            - "cmd_t": The command topic for buttons.
            - Additional parameters provided via kwargs.
       
       @note: The configuration dictionary will include different keys based on the entity type.
        """
        conf = {
            "name":self.name,
            "dev":self.device.device,
            "uniq_id":self.unique_id,
            "avty_t":self.device._mqttc.lw_topic, # Availability topic
        }
        if self.entity_type == 'sensor' or self.entity_type == 'binary_sensor':
            conf["stat_t"] = self.topic # State topic
        elif self.entity_type == 'button':
            conf["cmd_t"] = self.topic # Command topic
        for arg in kwargs:
            conf[arg] = kwargs[arg]
        return conf
    
    def discover(self):
        """
        @brief Publishes the device configuration to Home Assistant.
        
        This method serializes the device configuration (self.conf) to a JSON 
        formatted string and publishes it to the MQTT discovery topic 
        (self.discovery_topic) using the MQTT client (self.device._mqttc).
       
       @return None
        """
        self.device._mqttc.publish(self.discovery_topic, json.dumps(self.conf).encode('utf-8'))

class Sensor(Entity):
    """
    More information about MQTT Sensors: https://www.home-assistant.io/integrations/sensor.mqtt/
    """

    entity_type = 'sensor'
    _last_payload = None
    
    def publish(self, payload):
        """
        @brief Publishes a payload to the MQTT topic if it has changed since the last publish.

        @param payload: The data to be published. It will be converted to a string before publishing.
        This method converts the given payload to a string and compares it with the last published payload.
        If the payload has changed, it publishes the new payload to the MQTT topic specified in the
        configuration and updates the last published payload.
        """
        payload = str(payload)
        if payload == self._last_payload: return
        self.device._mqttc.publish(f'{self.conf['stat_t']}', payload)
        self._last_payload = payload

    def publish_last_payload(self):
        """
        @brief Publishes again already published payload if available
        """
        if self._last_payload is None:
            return
        self.device._mqttc.publish(f'{self.conf['stat_t']}', self._last_payload)   # REWORK: self.device.mqtt_publish(...), do not use internal ._mqttc ?
        print (f"DEBIG: publish_last_payload(): Published {self._last_payload=} for {self}")


class BinarySensor(Entity):
    """
    More information about MQTT Binary Sensors: https://www.home-assistant.io/integrations/binary_sensor.mqtt/
    """

    entity_type = 'binary_sensor'
    _last_payload = None
    
    def publish(self, payload):
        """
        @brief Publishes a payload to the MQTT topic if it has changed since the last publish.

        @param payload: The data to be published. It will be converted to a string before publishing.
        This method converts the given payload to a string and compares it with the last published payload.
        If the payload has changed, it publishes the new payload to the MQTT topic specified in the
        configuration and updates the last published payload.
        """

        payload = str(payload)
        if payload == self._last_payload: return
        self.device._mqttc.publish(f'{self.conf['stat_t']}', payload)
        self._last_payload = payload

class Button(Entity):
    """
    More information about MQTT Button: https://www.home-assistant.io/integrations/button.mqtt/
    """

    entity_type = 'button'
    _action = None

    def get_topic(self):
        return self.conf['cmd_t']
    
    def set_action(self, action):
        """
        @brief Set the action to be performed when the button is pressed.
        
        This method subscribes to the command topic specified in the configuration
        and sets the action to be executed when a message is received on that topic.
        
        @param action: A callable that takes one argument, the message received.
        """
        self.device._mqttc.subscribe(self.conf['cmd_t'])
        self._action = action
