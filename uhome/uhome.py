import time
import json

class Device:

    _mqttc = None # MQTT Client, provided by the user.
    _entities = [] # List of entities that belong to this device.

    def __init__(self, device_name, discovery_prefix='homeassistant', **kwargs):
        """
        Initializes the device with the given name and optional keyword arguments passed
        directly to the Home Assistant config.
        
        @param device_name: The name of the device.
        @type device_name: str
        
        @param discovery_prefix: The prefix used for discovery topics. Defaults to 'homeassistant'.
        @type discovery_prefix: str, optional
        
        @param kwargs: Additional keyword arguments to be added to the configuration of the device.
        
        @note: The device ID is generated by replacing spaces in the device name with underscores
        and converting to lowercase.
        """
        self.name = device_name
        self.id = self.name.replace(' ', '_').lower() # TODO: ö, ä, ü, ... not handled!
            # TODO: The ID of the device must only consist of characters from the character class [a-zA-Z0-9_-] (alphanumerics, underscore and hyphen).
            # https://www.home-assistant.io/integrations/mqtt/#discovery-topic
        self.discovery_prefix = discovery_prefix
        self.will_topic = f'{self.discovery_prefix}/availability/{self.id}'
        self.ha_status_topic = f'{self.discovery_prefix}/status'
        self.ha_status = None  # Last received HA status ( b'online' / b'offline')
        self.device = kwargs
        self.device['name'] = self.name
        self.device['ids'] = self.id

        self.topic_handlers = {}
        self.set_topic_handler(self.ha_status_topic, self.ha_status_handler)



    def connect(self, mqttc):
        """
        @brief Connects to the MQTT broker and sets up the necessary configurations.
        
        @param mqttc: The MQTT client instance to be used for the connection.
        
        This method performs the following actions:
        - Stores the provided MQTT client instance.
        - Sets the ping interval based on the client's keepalive value.
        - Sets the last will message to indicate the device is offline if it disconnects unexpectedly.
        - Sets the callback function for incoming MQTT messages.
        - Connects to the MQTT broker.
        - Publishes a message to indicate the device is online.
        - Subscribes to all topics on which entities have registered handlers
        
        @note The MQTT client instance must be properly configured before calling this method.
        """
        self._mqttc = mqttc
        self.ping_interval = int(self._mqttc.keepalive * 0.8)
        self._last_ping = time.time()
        self._mqttc.set_last_will(self.will_topic, 'offline', retain=True)
        self._mqttc.set_callback(self.mqtt_callback)
        self._mqttc.connect()
        self._mqttc.publish(self.will_topic, 'online', retain=True)

        for topic, handler in self.topic_handlers.items():
            self._mqttc.subscribe(topic)
            print (f"DEBUG: Subscribed to {topic=}")
        

    def set_topic_handler(self,topic, handler):
        """
        @brief Registers handler for MQTT topic

        @param topic: MQTT topic to subscribe and call handler for all messages

        @param handler: handler(topic, msg )

        Entities register handlers for their topics
        """
        prev_handler = self.topic_handlers.get(topic)
        if prev_handler:
            print (f"WARN: Replacing handler {prev_handler} for {topic=} with new handler: {handler}")
        else:
            print (f"DEBUG: Handler for {topic=} set: {handler}")
        self.topic_handlers[topic] = handler
        

    def mqtt_callback(self, topic, msg):
        """
        @brief Callback function for handling incoming MQTT messages.
        
        This function is called whenever a message is received on a subscribed MQTT topic.
        It decodes the topic and message, and then iterates through the list of entities
        to find the matching topic. If a match is found, it triggers the corresponding
        action for that entity.
        
        @param topic: The topic of the received MQTT message (bytes).
        
        @param msg: The payload of the received MQTT message (bytes).
        """
        print (f"DEBUG: mqtt_callback( {topic=}, {msg=} )")
        # EVENT: mqtt_callback( topic=b'homeassistant/button/uhome_test_device/state/identify', msg=b'PRESS' )
        # EVENT: mqtt_callback( topic=b'homeassistant/status', msg=b'offline' )

        decoded_topic = topic.decode()   # TODO: Rethink if we should use binary or string types for MQTT topics and messages
        handler = self.topic_handlers.get(decoded_topic)
        if handler:
            # print (f"DEBUG: {handler=} found for {decoded_topic=}")
            handler(decoded_topic,msg.decode())  # Let's use utf-8 strings for topics and messages
        else:
            print (f"WARN: No handler found for {decoded_topic=}")


    def ha_status_handler(self, topic, msg ):
        print (f"CALLED: ha_status_handler({topic=}, {msg=} )")
        self.ha_status = msg
        if msg == 'online':
            print ("INFO: HA state online")
            self.discover_all()
        elif msg == 'offline':
            print ("INFO: HA state offline")
        else:
            print (f"WARN: Unknown HA state received: {msg}")


    def loop(self):
        """
        @brief Main loop function to handle MQTT broker ping and message checking.
        
        This function performs two main tasks:
        1. Sends a ping to the MQTT broker if the ping interval has elapsed.
        2. Checks for new MQTT messages.
        
        @note This function handles the main loop of the device and should be called regularly.
        """
        ### Broker ping (required for Mosquitto >= 2.0!)
        now = time.time()
        if (now - self._last_ping) > self.ping_interval:
            self._mqttc.ping()
            self._last_ping = now
        
        self._mqttc.check_msg() # Check for new MQTT messages


    def sleep_ms(self,ms):
        """
        @brief Wrapper for time.sleep_ms()

        @param ms: Delay for given number of milliseconds, should be positive or 0. Same as in time.sleep_ms()

        @note Allows reimplemantation in child class if needed
        """
        time.sleep_ms(ms)


    def discover_all(self):
        """
        @brief (Re-)sends the discovery message for all entities to Home Assistant.
        
        This method iterates over all entities assigned to the device and calls
        their `discover` method to (re-)send the discovery message to Home Assistant.
        """
        for entity in self._entities:
            entity.discover()
        self.sleep_ms(3000)     # NOTE: This is ugly 
                                # Seems sending payload just after sending discovery paylod sometimes does not work
                                # Perhpahs we should send at once, ofert 1 sec, 3 secs 10 secs ?
        for entity in self._entities:
            entity.publish_last_payload()

        for entity in self._entities:
            entity.publish_last_payload()

class Entity:  

    def __init__(self, device, entity_name, **kwargs):
        """
        Create a new entity for the device.
        
        @param device: The device to which this entity belongs.
        @type device: Device
        
        @param entity_name: The name of the entity.
        @type entity_name: str
        
        @param kwargs: Additional configuration parameters for the entity,
        passed directly to the Home Assistant configuration.
        @type kwargs: dict
        """
        self.device = device
        self.device._entities.append(self)  # TODO: self.device.add_entity(self) ?
        self.name = entity_name
        self.entity = entity_name.replace(' ', '_').lower()
        self.unique_id = f"{self.device.id}_{self.entity}"
        self.topic_prefix = f'{self.device.discovery_prefix}/{self.entity_type}/{self.device.id}'
        self.discovery_topic = f'{self.topic_prefix}/{self.entity}/config'
        self.topic = f'{self.topic_prefix}/state/{self.entity}'  # TODO: -> .topic_state  TODO: {self.entity}/state ?
        self._last_payload = None


    def __str__(self):
        return f"{self.__class__.__name__}-{self.entity}"

    def make_conf(self, **kwargs):
        """
        Internal method to generate a configuration dictionary for the device.
        
        @param kwargs: Additional configuration parameters to be added to the dictionary.
        
        @return: A dictionary containing the configuration for the device.
            - "name": The name of the device.
            - "dev": The device identifier.
            - "uniq_id": The unique identifier for the device.
            - "avty_t": The availability topic for the device.
            - "stat_t": The state topic for sensors and binary sensors.
            - "cmd_t": The command topic for buttons.
            - Additional parameters provided via kwargs.
       
        @note: The configuration dictionary will include different keys based on the entity type.
        """
        conf = {
            "name":self.name,
            "dev":self.device.device,
            "uniq_id":self.unique_id,
            "avty_t":self.device._mqttc.lw_topic, # Availability topic
        }
        for arg in kwargs:
            conf[arg] = kwargs[arg]
        return conf
    
    def discover(self):
        """
        @brief Publishes the entity configuration to Home Assistant.
        
        This method serializes the entity configuration (from self.make_conf() ) to a JSON 
        formatted string and publishes it to the MQTT discovery topic 
        (self.discovery_topic) using the MQTT client (self.device._mqttc).
       
        @return None
        """
        conf = self.make_conf()
        self.device._mqttc.publish(self.discovery_topic, json.dumps(conf).encode('utf-8'))  # TODO: self.device.publish_json(topic, conf)

    

    def publish_last_payload(self):
        """
        @brief Publishes the entity state (sensor payload)

        Should be reimplemented in child classes
        """
        return 


class Sensor(Entity):
    """
    More information about MQTT Sensors: https://www.home-assistant.io/integrations/sensor.mqtt/
    """

    entity_type = 'sensor'

    def make_conf(self, **kwargs):
        conf = super().make_conf(**kwargs)
        conf["stat_t"] = self.topic # State topic  # TODO: -> .topic_state 
        return conf
    
    def publish(self, payload):
        """
        @brief Publishes a payload to the MQTT topic if it has changed since the last publish.

        @param payload: The data to be published. It will be converted to a string before publishing.
        This method converts the given payload to a string and compares it with the last published payload.
        If the payload has changed, it publishes the new payload to the MQTT topic specified in the
        configuration and updates the last published payload.
        """
        payload = str(payload)
        if payload == self._last_payload: return
        self.device._mqttc.publish(f'{self.topic}', payload) # REWORK: self.device.mqtt_publish(...), do not use internal ._mqttc ?
        self._last_payload = payload

    def publish_last_payload(self):
        """
        @brief Publishes again already published payload if was ever set        
        """
        if self._last_payload is None:
            return
        self.device._mqttc.publish(f'{self.topic}', self._last_payload)   # REWORK: self.device.mqtt_publish(...), do not use internal ._mqttc ?
        print (f"DEBUG: publish_last_payload(): Published {self._last_payload=} for {self}")


class BinarySensor(Entity):
    """
    More information about MQTT Binary Sensors: https://www.home-assistant.io/integrations/binary_sensor.mqtt/
    """
    entity_type = 'binary_sensor'
    

class Button(Entity):
    """
    More information about MQTT Button: https://www.home-assistant.io/integrations/button.mqtt/
    """

    entity_type = 'button'

    def __init__(self, device, entity_name, **kwargs):
        super().__init__(device, entity_name, **kwargs)
        self.topic_command = f'{self.topic_prefix}/set/{self.entity}'    # TODO: {self.topic_prefix}/{self.entity}/set
        self._action = None
        self.device.set_topic_handler(self.topic_command, self.command_handler)

    #  @staticmethod
    # def make_conf_add_topic_command(conf):
    #     conf["cmd_t"] = self.topic_command
    #    return conf

    def make_conf(self, **kwargs):
        conf = super().make_conf(**kwargs)
        conf["cmd_t"] = self.topic_command
        return conf


    def command_handler(self,topic,msg): 
        if self._action:
            self._action(msg)


    def set_action(self, action):
        """
        @brief Set the action to be performed when the simplest command is received.
        
        @param action: A callable that takes one argument, the message received.
        """
        # NOTE: There are entities with many actions
        self._action = action
